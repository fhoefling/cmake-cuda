# This file sets the basic flags for the NVIDIA CUDA language in CMake.
# It also loads the available platform file for the system-compiler
# if it exists.
# It also loads a system - compiler - processor (or target hardware)
# specific file, which is mainly useful for crosscompiling and embedded systems.

#=============================================================================
# Copyright 2002-2009 Kitware, Inc.
# Copyright 2008-2010 Peter Colberg
#
# Distributed under the OSI-approved BSD License (the "License");
# see accompanying file Copyright.txt for details.
#
# This software is distributed WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the License for more information.
#=============================================================================
# (To distributed this file outside of CMake, substitute the full
#  License text for the above reference.)


# some compilers use different extensions (e.g. sdcc uses .rel)
# so set the extension here first so it can be overridden by the compiler specific file
IF(UNIX)
  SET(CMAKE_CUDA_OUTPUT_EXTENSION .o)
ELSE(UNIX)
  SET(CMAKE_CUDA_OUTPUT_EXTENSION .obj)
ENDIF(UNIX)


GET_FILENAME_COMPONENT(CMAKE_BASE_NAME ${CMAKE_CUDA_COMPILER} NAME_WE)


# load the system-specific files
IF (NOT _INCLUDED_FILE)
  INCLUDE(Platform/${CMAKE_SYSTEM_NAME}-${CMAKE_BASE_NAME} OPTIONAL)
ENDIF (NOT _INCLUDED_FILE)


# This should be included before the _INIT variables are
# used to initialize the cache.  Since the rule variables
# have if blocks on them, users can still define them here.
# But, it should still be after the platform file so changes can
# be made to those values.

IF(CMAKE_USER_MAKE_RULES_OVERRIDE)
   INCLUDE(${CMAKE_USER_MAKE_RULES_OVERRIDE})
ENDIF(CMAKE_USER_MAKE_RULES_OVERRIDE)

IF(CMAKE_USER_MAKE_RULES_OVERRIDE_CUDA)
   INCLUDE(${CMAKE_USER_MAKE_RULES_OVERRIDE_CUDA})
ENDIF(CMAKE_USER_MAKE_RULES_OVERRIDE_CUDA)


# for most systems a module is the same as a shared library
# so unless the variable CMAKE_MODULE_EXISTS is set just
# copy the values from the LIBRARY variables
IF(NOT CMAKE_MODULE_EXISTS)
  SET(CMAKE_SHARED_MODULE_CUDA_FLAGS ${CMAKE_SHARED_LIBRARY_CUDA_FLAGS})
ENDIF(NOT CMAKE_MODULE_EXISTS)
# Create a set of shared library variable specific to CUDA
# For 90% of the systems, these are the same flags as the C versions
# so if these are not set just copy the flags from the c version
IF(NOT CMAKE_SHARED_LIBRARY_CREATE_CUDA_FLAGS)
  SET(CMAKE_SHARED_LIBRARY_CREATE_CUDA_FLAGS ${CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS})
ENDIF(NOT CMAKE_SHARED_LIBRARY_CREATE_CUDA_FLAGS)

IF(NOT CMAKE_SHARED_LIBRARY_CUDA_FLAGS)
  SET(CMAKE_SHARED_LIBRARY_CUDA_FLAGS ${CMAKE_SHARED_LIBRARY_C_FLAGS})
ENDIF(NOT CMAKE_SHARED_LIBRARY_CUDA_FLAGS)

IF(NOT DEFINED CMAKE_SHARED_LIBRARY_LINK_CUDA_FLAGS)
  SET(CMAKE_SHARED_LIBRARY_LINK_CUDA_FLAGS ${CMAKE_SHARED_LIBRARY_LINK_C_FLAGS})
ENDIF(NOT DEFINED CMAKE_SHARED_LIBRARY_LINK_CUDA_FLAGS)

IF(NOT CMAKE_SHARED_LIBRARY_RUNTIME_CUDA_FLAG)
  SET(CMAKE_SHARED_LIBRARY_RUNTIME_CUDA_FLAG ${CMAKE_SHARED_LIBRARY_RUNTIME_C_FLAG})
ENDIF(NOT CMAKE_SHARED_LIBRARY_RUNTIME_CUDA_FLAG)

IF(NOT CMAKE_SHARED_LIBRARY_RUNTIME_CUDA_FLAG_SEP)
  SET(CMAKE_SHARED_LIBRARY_RUNTIME_CUDA_FLAG_SEP ${CMAKE_SHARED_LIBRARY_RUNTIME_C_FLAG_SEP})
ENDIF(NOT CMAKE_SHARED_LIBRARY_RUNTIME_CUDA_FLAG_SEP)

IF(NOT CMAKE_SHARED_LIBRARY_RPATH_LINK_CUDA_FLAG)
  SET(CMAKE_SHARED_LIBRARY_RPATH_LINK_CUDA_FLAG ${CMAKE_SHARED_LIBRARY_RPATH_LINK_C_FLAG})
ENDIF(NOT CMAKE_SHARED_LIBRARY_RPATH_LINK_CUDA_FLAG)

IF(NOT CMAKE_EXECUTABLE_RUNTIME_CUDA_FLAG)
  SET(CMAKE_EXECUTABLE_RUNTIME_CUDA_FLAG ${CMAKE_SHARED_LIBRARY_RUNTIME_CUDA_FLAG})
ENDIF(NOT CMAKE_EXECUTABLE_RUNTIME_CUDA_FLAG)

IF(NOT CMAKE_EXECUTABLE_RUNTIME_CUDA_FLAG_SEP)
  SET(CMAKE_EXECUTABLE_RUNTIME_CUDA_FLAG_SEP ${CMAKE_SHARED_LIBRARY_RUNTIME_CUDA_FLAG_SEP})
ENDIF(NOT CMAKE_EXECUTABLE_RUNTIME_CUDA_FLAG_SEP)

IF(NOT CMAKE_EXECUTABLE_RPATH_LINK_CUDA_FLAG)
  SET(CMAKE_EXECUTABLE_RPATH_LINK_CUDA_FLAG ${CMAKE_SHARED_LIBRARY_RPATH_LINK_CUDA_FLAG})
ENDIF(NOT CMAKE_EXECUTABLE_RPATH_LINK_CUDA_FLAG)

IF(NOT DEFINED CMAKE_SHARED_LIBRARY_LINK_CUDA_WITH_RUNTIME_PATH)
  SET(CMAKE_SHARED_LIBRARY_LINK_CUDA_WITH_RUNTIME_PATH ${CMAKE_SHARED_LIBRARY_LINK_C_WITH_RUNTIME_PATH})
ENDIF(NOT DEFINED CMAKE_SHARED_LIBRARY_LINK_CUDA_WITH_RUNTIME_PATH)

IF(NOT CMAKE_INCLUDE_FLAG_CUDA)
  SET(CMAKE_INCLUDE_FLAG_CUDA ${CMAKE_INCLUDE_FLAG_C})
ENDIF(NOT CMAKE_INCLUDE_FLAG_CUDA)

IF(NOT CMAKE_INCLUDE_FLAG_SEP_CUDA)
  SET(CMAKE_INCLUDE_FLAG_SEP_CUDA ${CMAKE_INCLUDE_FLAG_SEP_C})
ENDIF(NOT CMAKE_INCLUDE_FLAG_SEP_CUDA)

# repeat for modules
IF(NOT CMAKE_SHARED_MODULE_CREATE_CUDA_FLAGS)
  SET(CMAKE_SHARED_MODULE_CREATE_CUDA_FLAGS ${CMAKE_SHARED_MODULE_CREATE_C_FLAGS})
ENDIF(NOT CMAKE_SHARED_MODULE_CREATE_CUDA_FLAGS)

IF(NOT CMAKE_SHARED_MODULE_CUDA_FLAGS)
  SET(CMAKE_SHARED_MODULE_CUDA_FLAGS ${CMAKE_SHARED_MODULE_C_FLAGS})
ENDIF(NOT CMAKE_SHARED_MODULE_CUDA_FLAGS)

IF(NOT CMAKE_SHARED_MODULE_RUNTIME_CUDA_FLAG)
  SET(CMAKE_SHARED_MODULE_RUNTIME_CUDA_FLAG ${CMAKE_SHARED_MODULE_RUNTIME_FLAG})
ENDIF(NOT CMAKE_SHARED_MODULE_RUNTIME_CUDA_FLAG)

IF(NOT CMAKE_SHARED_MODULE_RUNTIME_CUDA_FLAG_SEP)
  SET(CMAKE_SHARED_MODULE_RUNTIME_CUDA_FLAG_SEP ${CMAKE_SHARED_MODULE_RUNTIME_FLAG_SEP})
ENDIF(NOT CMAKE_SHARED_MODULE_RUNTIME_CUDA_FLAG_SEP)

# Initialize CUDA link type selection flags from C versions.
FOREACH(type SHARED_LIBRARY SHARED_MODULE EXE)
  IF(NOT CMAKE_${type}_LINK_STATIC_CUDA_FLAGS)
    SET(CMAKE_${type}_LINK_STATIC_CUDA_FLAGS
      ${CMAKE_${type}_LINK_STATIC_C_FLAGS})
  ENDIF(NOT CMAKE_${type}_LINK_STATIC_CUDA_FLAGS)
  IF(NOT CMAKE_${type}_LINK_DYNAMIC_CUDA_FLAGS)
    SET(CMAKE_${type}_LINK_DYNAMIC_CUDA_FLAGS
      ${CMAKE_${type}_LINK_DYNAMIC_C_FLAGS})
  ENDIF(NOT CMAKE_${type}_LINK_DYNAMIC_CUDA_FLAGS)
ENDFOREACH(type)

# add the flags to the cache based
# on the initial values computed in the platform/*.cmake files
# use _INIT variables so that this only happens the first time
# and you can set these flags in the cmake cache
SET(CMAKE_CUDA_FLAGS_INIT "$ENV{NVCCFLAGS} ${CMAKE_CUDA_FLAGS_INIT}")
# avoid just having a space as the initial value for the cache
IF(CMAKE_CUDA_FLAGS_INIT STREQUAL " ")
  SET(CMAKE_CUDA_FLAGS_INIT)
ENDIF(CMAKE_CUDA_FLAGS_INIT STREQUAL " ")
SET (CMAKE_CUDA_FLAGS "${CMAKE_CUDA_FLAGS_INIT}" CACHE STRING
     "Flags used by the compiler during all build types.")

IF(NOT CMAKE_NOT_USING_CONFIG_FLAGS)
  SET (CMAKE_CUDA_FLAGS_DEBUG "${CMAKE_CUDA_FLAGS_DEBUG_INIT}" CACHE STRING
     "Flags used by the compiler during debug builds.")
  SET (CMAKE_CUDA_FLAGS_MINSIZEREL "${CMAKE_CUDA_FLAGS_MINSIZEREL_INIT}" CACHE STRING
      "Flags used by the compiler during release minsize builds.")
  SET (CMAKE_CUDA_FLAGS_RELEASE "${CMAKE_CUDA_FLAGS_RELEASE_INIT}" CACHE STRING
     "Flags used by the compiler during release builds (/MD /Ob1 /Oi /Ot /Oy /Gs will produce slightly less optimized but smaller files).")
  SET (CMAKE_CUDA_FLAGS_RELWITHDEBINFO "${CMAKE_CUDA_FLAGS_RELWITHDEBINFO_INIT}" CACHE STRING
     "Flags used by the compiler during Release with Debug Info builds.")

ENDIF(NOT CMAKE_NOT_USING_CONFIG_FLAGS)

IF(CMAKE_CUDA_STANDARD_LIBRARIES_INIT)
  SET(CMAKE_CUDA_STANDARD_LIBRARIES "${CMAKE_CUDA_STANDARD_LIBRARIES_INIT}"
    CACHE STRING "Libraries linked by default with all CUDA applications.")
  MARK_AS_ADVANCED(CMAKE_CUDA_STANDARD_LIBRARIES)
ENDIF(CMAKE_CUDA_STANDARD_LIBRARIES_INIT)

INCLUDE(CMakeCommonLanguageInclude)

# now define the following rules:
# CMAKE_CUDA_CREATE_SHARED_LIBRARY
# CMAKE_CUDA_CREATE_SHARED_MODULE
# CMAKE_CUDA_CREATE_STATIC_LIBRARY
# CMAKE_CUDA_COMPILE_OBJECT
# CMAKE_CUDA_LINK_EXECUTABLE

# variables supplied by the generator at use time
# <TARGET>
# <TARGET_BASE> the target without the suffix
# <OBJECTS>
# <OBJECT>
# <LINK_LIBRARIES>
# <FLAGS>
# <LINK_FLAGS>

# NVCC compiler information
# <CMAKE_CUDA_COMPILER>
# <CMAKE_SHARED_LIBRARY_CREATE_CUDA_FLAGS>
# <CMAKE_CUDA_SHARED_MODULE_CREATE_FLAGS>
# <CMAKE_CUDA_LINK_FLAGS>

# Static library tools
# <CMAKE_AR>
# <CMAKE_RANLIB>


# create a shared CUDA library
IF(NOT CMAKE_CUDA_CREATE_SHARED_LIBRARY)
  SET(CMAKE_CUDA_CREATE_SHARED_LIBRARY
      "<CMAKE_CUDA_COMPILER> <CMAKE_SHARED_LIBRARY_CUDA_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CUDA_FLAGS> <CMAKE_SHARED_LIBRARY_SONAME_CUDA_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>")
ENDIF(NOT CMAKE_CUDA_CREATE_SHARED_LIBRARY)

# create a c++ shared module copy the shared library rule by default
IF(NOT CMAKE_CUDA_CREATE_SHARED_MODULE)
  SET(CMAKE_CUDA_CREATE_SHARED_MODULE ${CMAKE_CUDA_CREATE_SHARED_LIBRARY})
ENDIF(NOT CMAKE_CUDA_CREATE_SHARED_MODULE)


# create a CUDA static library
IF(NOT CMAKE_CUDA_CREATE_STATIC_LIBRARY)
  SET(CMAKE_CUDA_CREATE_STATIC_LIBRARY
      "<CMAKE_AR> cr <TARGET> <LINK_FLAGS> <OBJECTS> "
      "<CMAKE_RANLIB> <TARGET> ")
ENDIF(NOT CMAKE_CUDA_CREATE_STATIC_LIBRARY)

# compile a CUDA file into an object file
IF(NOT CMAKE_CUDA_COMPILE_OBJECT)
  SET(CMAKE_CUDA_COMPILE_OBJECT
    "<CMAKE_CUDA_COMPILER>  <DEFINES> <FLAGS> -o <OBJECT> -c <SOURCE>")
ENDIF(NOT CMAKE_CUDA_COMPILE_OBJECT)

IF(NOT CMAKE_CUDA_LINK_EXECUTABLE)
  SET(CMAKE_CUDA_LINK_EXECUTABLE
    "<CMAKE_CUDA_COMPILER>  <FLAGS> <CMAKE_CUDA_LINK_FLAGS> <LINK_FLAGS> <OBJECTS>  -o <TARGET> <LINK_LIBRARIES>")
ENDIF(NOT CMAKE_CUDA_LINK_EXECUTABLE)

IF(NOT CMAKE_CUDA_CREATE_PREPROCESSED_SOURCE)
  SET (CMAKE_CUDA_CREATE_PREPROCESSED_SOURCE "<CMAKE_CUDA_COMPILER> <FLAGS> -E <SOURCE> > <PREPROCESSED_SOURCE>")
ENDIF(NOT CMAKE_CUDA_CREATE_PREPROCESSED_SOURCE)

IF(NOT CMAKE_CUDA_CREATE_ASSEMBLY_SOURCE)
  SET (CMAKE_CUDA_CREATE_ASSEMBLY_SOURCE "<CMAKE_CUDA_COMPILER> <FLAGS> -ptx <SOURCE> -o <ASSEMBLY_SOURCE>")
ENDIF(NOT CMAKE_CUDA_CREATE_ASSEMBLY_SOURCE)

MARK_AS_ADVANCED(
CMAKE_BUILD_TOOL
CMAKE_VERBOSE_MAKEFILE
CMAKE_CUDA_FLAGS
CMAKE_CUDA_FLAGS_RELEASE
CMAKE_CUDA_FLAGS_RELWITHDEBINFO
CMAKE_CUDA_FLAGS_MINSIZEREL
CMAKE_CUDA_FLAGS_DEBUG)

SET(CMAKE_CUDA_INFORMATION_LOADED 1)

